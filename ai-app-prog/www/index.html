<html>
<head>
<title>AI Application Programming Ruby port</title>
</head>
<body>
<a href="top"><p></a>
<p>In an effort to learn more about AI programming techniques, I'm trying to port M. Tim Jones' <a href="http://www.charlesriver.com/titles/aiapp.html">AI Application Programming</a> examples from C to Ruby.  I'm planning to port these <a href="#notes">(porting notes are here)</a> in no particular order.

<ul>
<li><a href="#anneal">Simulated Annealing</a>
<li>Adaptive Resonance Theory
<li><a href="#ant">Ant Algorithms</a>
<li>Neural Networks and the Backpropagation Algorithm
<li>Genetic Algorithms
<li>Artificial Life
<li>Expert Systems
<li><a href="#fuzzy">Fuzzy Logic</a>
<li><a href="#bigram">The Bigram Model (Hidden Markov Models)</a>
<li>Intelligent Agents
</ul>

<p>Tim was kind enough to pass on the book's <a href="http://rubyforge.org/docman/index.php?group_id=97">erratum</a> to me - current as of Oct 06 2003.
<p>This project is hosted by <a href="http://rubyforge.org/">RubyForge</a>, forums and such-like are <a href="http://rubyforge.org/projects/ai-app-prog/">here</a>.

<hr>

<a name="anneal"></a>
<h3><a href="#top">Chapter 2 - Simulated Annealing</a></h3>
<p>Updated 10/23/03: Done with translation of the n-Queens solver, <a href="http://rubyforge.org/cgi-bin/viewcvs/cgi/viewcvs.cgi/ai-app-prog/src/ch2/?cvsroot=ai-app-prog">code is here</a>.  Here's a solution with 8 queens (took about 16 seconds to run):
<pre>
. . Q . . . . .
. . . . Q . . .
. . . . . . . Q
. . . Q . . . .
Q . . . . . . .
. . . . . . Q .
. Q . . . . . .
. . . . . Q . .
</pre>
<hr>

<a name="ant"></a>
<h3><a href="#top">Chapter 4 - Ant Algorithms</a></h3>
<p>Updated 10/22/03: Traveling Salesman via ant algorithm is done, <a href="http://rubyforge.org/cgi-bin/viewcvs/cgi/viewcvs.cgi/ai-app-prog/src/ch4/?cvsroot=ai-app-prog">code is here</a>.
<ul>
<li>TODO: Refactor the code a bit more; use more objects and fewer array indexes
<li>Here's the graph of the cities and the calculated shortest path for 30 cities traversed by 30 ants.  It took 90 seconds to run:
<p><img src="ch4/cities.png"/>
</ul>

<hr>

<a name="fuzzy"></a>
<h3><a href="#top">Chapter 9 - Fuzzy Logic</a></h3>
<p>Updated 10/16/03: Battery charger and predator prey examples complete, code is <a href="http://rubyforge.org/cgi-bin/viewcvs/cgi/viewcvs.cgi/ai-app-prog/src/ch9/?cvsroot=ai-app-prog">here</a>.  
<ul>
<li>The predator/prey example was fun because I had to relearn some trigonometry.  Also, I had to tweak the membership functions a bit - the first time through I made the center spike profile too wide and so the predator kept waiting too long to turn towards the prey.
<li>To regenerate the predator graph: <p><code>./fuzzy.rb > predator_data.txt && ./predator_gnuplot</code>
<li>To regenerate the battery graph: <p><code>./fuzzy.rb -battery > battery_data.txt && ./battery_gnuplot</code>
<li>TODO: Write partial FCL parser, encode rules, load from file
</ul>
<p>Battery charger example: below is a graph (thanks gnuplot!) showing the relationships between the battery's voltage and temperature - you can see when the fast charger kicks in and when it falls back to trickle charge mode. 
<p><img src="ch9/battery.png"/>
<p>Predator/prey example: below is an image of the predator seeing the prey and turning towards it.
<p><img src="ch9/predator.png"/>

<hr>

<a name="bigram"></a>
<h3><a href="#top">Chapter 10 - The Bigram Model</a></h3>
<p>10/29/03: Working on next_word(), code is <a href="http://rubyforge.org/cgi-bin/viewcvs/cgi/viewcvs.cgi/ai-app-prog/src/ch10/?cvsroot=ai-app-prog">here</a>.

<hr>

<a name="notes"></a>
<h3><a href="#top">Porting notes</a></h3>
<ul>
<li>The code in this book doesn't use setjmp() or doubly-indirect pointers or other hairy C stuff - it's mostly just loops and functions.  This makes porting it a lot easier.
<li>I'm porting in several steps:
<ol>
<li>Do an initial "raw" port by just translating C to Ruby
<li>Pick a blob of associated data items, refactor them into a Ruby class
<li>Add tests, back to step 2
</ol>
<li>Ruby is _so_ much less wordy than C - not having to type all the parentheses and semicolons and such is really nice.
<li>If someone wanted to do this and preserve speed, it'd probably be best to just write Ruby extensions that wrap the AI stuff (thx to Rich Kilmer for this comment)
<li>Writing more tests will alleviate some problems I'm having - i.e., forgetting the "@" on a instance variable.  It's kind of an odd situation, though... I don't really understand how some of the algorithms work, so writing tests for them is hard since I have to step thru the entire function with sample values.  I feel like the tests I'm writing are too high-level or something.
<li>Watch for C code like this:
<pre>
if (foo) {
	/* do something */
}
</pre>
It needs to be translated to
<pre>
if foo != 0 
	# do something
end
</pre>
in Ruby.  In other words. "non zero" in C needs to be translated to "not nil and not zero" in Ruby.
<li>A <code>do..while</code> forever loop in C can be done like this in Ruby:
<pre>
begin
	# do stuff
end until !true
</pre>
<li>Translate pre- and post-increment statements correctly.  C code like this:
<pre>
int x = 0;
printf("Value = %d\n", x++);
</pre>
prints out "Value = 0".  Since Ruby doesn't have an postincrement operator, make sure you put the incrementor _after_ the print statement.  Like this:
<pre>
x = 0
puts "Value = #{x}\n"
x += 1
</pre>
This bit me something fierce on the Ant Algorithm code.  Of course, what really bit me was that I didn't write any unit tests.  Gack.
<li>C has the <code>static</code> keyword which can be used inside functions to indicate that a variable is only initialized once.  This translates to a class-level variable in Ruby.  At least, that's the best comparison I can think of at the moment, comments are welcome.
</ul>

</body>
</html>


